// Code generated by Wire. DO NOT EDIT.

//go:generate wire
//go:build !wireinject
// +build !wireinject

package wire

import (
	"github.com/minghsu0107/go-random-chat/pkg/chat"
	"github.com/minghsu0107/go-random-chat/pkg/common"
	"github.com/minghsu0107/go-random-chat/pkg/config"
	"github.com/minghsu0107/go-random-chat/pkg/infra"
	"github.com/minghsu0107/go-random-chat/pkg/match"
	"github.com/minghsu0107/go-random-chat/pkg/uploader"
	"github.com/minghsu0107/go-random-chat/pkg/user"
	"github.com/minghsu0107/go-random-chat/pkg/web"
)

// Injectors from wire.go:

func InitializeWebServer(name string) (*common.Server, error) {
	httpLogrus := common.NewHttpLogrus()
	configConfig, err := config.NewConfig()
	if err != nil {
		return nil, err
	}
	engine := web.NewGinServer(name, httpLogrus)
	httpServer := web.NewHttpServer(name, httpLogrus, configConfig, engine)
	router := web.NewRouter(httpServer)
	infraCloser := web.NewInfraCloser()
	observibilityInjector := common.NewObservibilityInjector(configConfig)
	server := common.NewServer(name, router, infraCloser, observibilityInjector)
	return server, nil
}

func InitializeChatServer(name string) (*common.Server, error) {
	httpLogrus := common.NewHttpLogrus()
	configConfig, err := config.NewConfig()
	if err != nil {
		return nil, err
	}
	engine := chat.NewGinServer(name, httpLogrus, configConfig)
	melodyChatConn := chat.NewMelodyChatConn(configConfig)
	subscriber, err := infra.NewKafkaSubscriber(configConfig)
	if err != nil {
		return nil, err
	}
	messageSubscriber, err := chat.NewMessageSubscriber(name, subscriber, melodyChatConn)
	if err != nil {
		return nil, err
	}
	universalClient, err := infra.NewRedisClient(configConfig)
	if err != nil {
		return nil, err
	}
	redisCache := infra.NewRedisCache(universalClient)
	userRepo := chat.NewUserRepo(redisCache)
	userService := chat.NewUserService(userRepo)
	publisher, err := infra.NewKafkaPublisher(configConfig)
	if err != nil {
		return nil, err
	}
	messageRepo := chat.NewMessageRepo(configConfig, redisCache, publisher)
	idGenerator, err := common.NewSonyFlake()
	if err != nil {
		return nil, err
	}
	messageService := chat.NewMessageService(messageRepo, userRepo, idGenerator)
	channelRepo := chat.NewChannelRepo(redisCache)
	channelService := chat.NewChannelService(channelRepo, userRepo, idGenerator)
	httpServer := chat.NewHttpServer(name, httpLogrus, configConfig, engine, melodyChatConn, messageSubscriber, userService, messageService, channelService)
	grpcLogrus := common.NewGrpcLogrus()
	grpcServer := chat.NewGrpcServer(grpcLogrus, configConfig, userService, channelService)
	router := chat.NewRouter(httpServer, grpcServer)
	infraCloser := chat.NewInfraCloser()
	observibilityInjector := common.NewObservibilityInjector(configConfig)
	server := common.NewServer(name, router, infraCloser, observibilityInjector)
	return server, nil
}

func InitializeMatchServer(name string) (*common.Server, error) {
	httpLogrus := common.NewHttpLogrus()
	configConfig, err := config.NewConfig()
	if err != nil {
		return nil, err
	}
	engine := match.NewGinServer(name, httpLogrus, configConfig)
	melodyMatchConn := match.NewMelodyMatchConn()
	userClientConn, err := match.NewUserClientConn(configConfig)
	if err != nil {
		return nil, err
	}
	chatClientConn, err := match.NewChatClientConn(configConfig)
	if err != nil {
		return nil, err
	}
	userRepo := match.NewUserRepo(userClientConn, chatClientConn)
	userService := match.NewUserService(userRepo)
	subscriber, err := infra.NewKafkaSubscriber(configConfig)
	if err != nil {
		return nil, err
	}
	matchSubscriber, err := match.NewMatchSubscriber(name, melodyMatchConn, userService, subscriber)
	if err != nil {
		return nil, err
	}
	universalClient, err := infra.NewRedisClient(configConfig)
	if err != nil {
		return nil, err
	}
	redisCache := infra.NewRedisCache(universalClient)
	publisher, err := infra.NewKafkaPublisher(configConfig)
	if err != nil {
		return nil, err
	}
	matchingRepo := match.NewMatchingRepo(redisCache, publisher)
	channelRepo := match.NewChannelRepo(chatClientConn)
	matchingService := match.NewMatchingService(matchingRepo, channelRepo)
	httpServer := match.NewHttpServer(name, httpLogrus, configConfig, engine, melodyMatchConn, matchSubscriber, userService, matchingService)
	router := match.NewRouter(httpServer)
	infraCloser := match.NewInfraCloser()
	observibilityInjector := common.NewObservibilityInjector(configConfig)
	server := common.NewServer(name, router, infraCloser, observibilityInjector)
	return server, nil
}

func InitializeUploaderServer(name string) (*common.Server, error) {
	httpLogrus := common.NewHttpLogrus()
	configConfig, err := config.NewConfig()
	if err != nil {
		return nil, err
	}
	engine := uploader.NewGinServer(name, httpLogrus, configConfig)
	httpServer := uploader.NewHttpServer(name, httpLogrus, configConfig, engine)
	router := uploader.NewRouter(httpServer)
	infraCloser := uploader.NewInfraCloser()
	observibilityInjector := common.NewObservibilityInjector(configConfig)
	server := common.NewServer(name, router, infraCloser, observibilityInjector)
	return server, nil
}

func InitializeUserServer(name string) (*common.Server, error) {
	httpLogrus := common.NewHttpLogrus()
	configConfig, err := config.NewConfig()
	if err != nil {
		return nil, err
	}
	engine := user.NewGinServer(name, httpLogrus, configConfig)
	universalClient, err := infra.NewRedisClient(configConfig)
	if err != nil {
		return nil, err
	}
	redisCache := infra.NewRedisCache(universalClient)
	userRepo := user.NewUserRepo(redisCache)
	idGenerator, err := common.NewSonyFlake()
	if err != nil {
		return nil, err
	}
	userService := user.NewUserService(userRepo, idGenerator)
	httpServer := user.NewHttpServer(name, httpLogrus, configConfig, engine, userService)
	grpcLogrus := common.NewGrpcLogrus()
	grpcServer := user.NewGrpcServer(grpcLogrus, configConfig, userService)
	router := user.NewRouter(httpServer, grpcServer)
	infraCloser := user.NewInfraCloser()
	observibilityInjector := common.NewObservibilityInjector(configConfig)
	server := common.NewServer(name, router, infraCloser, observibilityInjector)
	return server, nil
}
